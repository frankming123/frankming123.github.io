<!DOCTYPE html>
<html lang="zh_CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://staight.github.io').hostname,
    root: '/',
    scheme: 'Mist',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"mac"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="这篇文章将基本的SQL语句列一下 SQL语言简介PostgreSQL是一个关系型数据库管理系统(relational database management system,RDBMS).这表明它是一个使用关系(retional)存储数据的系统">
<meta property="og:type" content="article">
<meta property="og:title" content="Postgres-SQL语句">
<meta property="og:url" content="https://staight.github.io/2018/08/25/Postgres-SQL%E8%AF%AD%E5%8F%A5/index.html">
<meta property="og:site_name" content="staight">
<meta property="og:description" content="这篇文章将基本的SQL语句列一下 SQL语言简介PostgreSQL是一个关系型数据库管理系统(relational database management system,RDBMS).这表明它是一个使用关系(retional)存储数据的系统">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2018-08-25T03:00:22.000Z">
<meta property="article:modified_time" content="2019-10-02T17:49:50.000Z">
<meta property="article:author" content="staight">
<meta property="article:tag" content="PostgreSQL">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://staight.github.io/2018/08/25/Postgres-SQL%E8%AF%AD%E5%8F%A5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>Postgres-SQL语句 | staight</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">staight</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-杂物">

    <a href="/sundries/" rel="section"><i class="fa fa-fw fa-calendar"></i>杂物</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/staight" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh_CN">
    <link itemprop="mainEntityOfPage" href="https://staight.github.io/2018/08/25/Postgres-SQL%E8%AF%AD%E5%8F%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="staight">
      <meta itemprop="description" content="keep it simple and stupid">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="staight">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Postgres-SQL语句
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-25 11:00:22" itemprop="dateCreated datePublished" datetime="2018-08-25T11:00:22+08:00">2018-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-10-03 01:49:50" itemprop="dateModified" datetime="2019-10-03T01:49:50+08:00">2019-10-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>这篇文章将基本的SQL语句列一下</p>
<h2 id="SQL语言简介"><a href="#SQL语言简介" class="headerlink" title="SQL语言简介"></a>SQL语言简介</h2><p>PostgreSQL是一个关系型数据库管理系统(<code>relational database management system,RDBMS</code>).这表明它是一个使用关系(<code>retional</code>)存储数据的系统</p>
<p>关系是表格(<code>table</code>)在数学层面上的术语.每一个表格都是行(<code>row</code>)的集合.每一个给定表格的行都有着相同名称的列(<code>column</code>),并且每一列都是一个指定的数据类型</p>
<p>多个表格组成了数据库,多个被PostgreSQL服务端管理的数据库则构成了一个叫做集群(<code>cluster</code>)的数据库</p>
<h2 id="创建表格-create"><a href="#创建表格-create" class="headerlink" title="创建表格(create)"></a>创建表格(create)</h2><p>可以通过指定表格名称,列的名称以及它们的类型来创建一个表格:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> weather (</span><br><span class="line">    city <span class="built_in">varchar</span>(<span class="number">80</span>),</span><br><span class="line">    temp_lo <span class="built_in">int</span>, <span class="comment">-- low temperature,最低温度</span></span><br><span class="line">    temp_hi <span class="built_in">int</span>, <span class="comment">-- high temperature,最高温度</span></span><br><span class="line">    prcp <span class="built_in">real</span>, <span class="comment">-- precipitation,降水量</span></span><br><span class="line">    <span class="built_in">date</span> <span class="built_in">date</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>两个破折号(<code>--</code>)之后的内容为注释.SQL的关键词和标识符大小写不敏感,除非标识符在双引号中</p>
<ul>
<li><code>varchar(80)</code>指定了一个数据类型,它可以存储任意类型的字符串,且长度至多为80个字符</li>
<li><code>int</code>是一种常见的数值类型</li>
<li><code>real</code>是一个存储单精度浮点数的类型</li>
<li><code>date</code>是日期类型</li>
</ul>
<p><code>PostgreSQL</code>支持标准SQL类型,例如:<code>int, smallint, real, double precision, char(N), varchar(N), date, time, timestamp, and interval</code>.除此之外,它还提供一些其它一些易用的类型</p>
<p>第二个创建表格的示例:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> cities (</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">80</span>),</span><br><span class="line">    location point</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>其中,<code>point</code>是一个PostgreSQL定义的数据类型,它是一个二维坐标</p>
<h2 id="删除表格-drop"><a href="#删除表格-drop" class="headerlink" title="删除表格(drop)"></a>删除表格(drop)</h2><p>如果不再需要一个表格,或者想要重新创建它的话,可以选择删除它:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> tablename;</span><br></pre></td></tr></table></figure>

<h2 id="插入-insert"><a href="#插入-insert" class="headerlink" title="插入(insert)"></a>插入(insert)</h2><p><code>INSERT</code>语句用来在指定表格中插入一行数据.例如:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> weather <span class="keyword">VALUES</span> (<span class="string">'南京'</span>, <span class="number">25</span>, <span class="number">30</span>, <span class="number">0.8</span>, <span class="string">'2018-8-22'</span>);</span><br></pre></td></tr></table></figure>

<p>注意值的输入顺序应该完全遵循创建表格时列名的输入顺序.不是数值类型的常数往往应该被包含在单引号(<code>&#39;</code>)中</p>
<p><code>point</code>类型需要一个坐标对作为输入:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> cities <span class="keyword">VALUES</span> (<span class="string">'南京'</span>, <span class="string">'(32.0, 118.0)'</span>);</span><br></pre></td></tr></table></figure>

<p>上述示例需要记得列名的顺序,还有另外一种可选方案可以精确的选择每一个值的输入顺序:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> weather (city, temp_lo, temp_hi, prcp, <span class="built_in">date</span>)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">'南京'</span>, <span class="number">25</span>, <span class="number">30</span>, <span class="number">0.8</span>, <span class="string">'2018-8-22'</span>);</span><br></pre></td></tr></table></figure>

<p>这样就可以使用不同的顺序插入值,甚至可以忽略掉一些列名</p>
<p>在需要插入大量数据时,可以选择使用<code>COPY</code>语句从文本文件中读取数据.这通常比<code>INSERT</code>更快:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY weather FROM '/home/user/weather.txt';</span><br></pre></td></tr></table></figure>

<h2 id="查询-select"><a href="#查询-select" class="headerlink" title="查询(select)"></a>查询(select)</h2><p>SQL语句<code>SELECT</code>用来从一个表格中获取数据:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># select * from weather;</span></span><br><span class="line"> city | temp_lo | temp_hi | prcp |    date</span><br><span class="line"><span class="comment">------+---------+---------+------+------------</span></span><br><span class="line"> 南京 |      25 |      30 |  0.8 | 2018-08-22</span><br><span class="line"> 南京 |      22 |      30 |  0.3 | 2018-08-23</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>

<p><code>*</code>是所有列的简称,在<code>weather</code>表中相当于:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> city, temp_lo, temp_hi, prcp, <span class="built_in">date</span> <span class="keyword">FROM</span> weather;</span><br></pre></td></tr></table></figure>

<p>也可以写表达式,而不仅仅是列的引用:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT city, (temp_hi+temp_lo)/2 AS temp_avg, date FROM weather;</span></span><br><span class="line"> city | temp_avg |    date</span><br><span class="line"><span class="comment">------+----------+------------</span></span><br><span class="line"> 南京 |       27 | 2018-08-22</span><br><span class="line"> 南京 |       26 | 2018-08-23</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>

<p><code>AS</code>子句用来命名新生成的列</p>
<p>查询也可以添加<code>WHERE</code>子句来选择想要的行.<code>WHERE</code>子句包含一个布尔类型的表达式,只有那些表达式返回真的行才会被返回.<code>WHERE</code>子句允许使用布尔操作符如<code>AND</code>,<code>OR</code>,<code>NOT</code></p>
<p>例如:查询南京的下雨天</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT * FROM weather WHERE city='南京' AND prcp&gt;0.0;</span></span><br><span class="line"> city | temp_lo | temp_hi | prcp |    date    </span><br><span class="line"><span class="comment">------+---------+---------+------+------------</span></span><br><span class="line"> 南京 |      25 |      30 |  0.8 | 2018-08-22</span><br><span class="line"> 南京 |      22 |      30 |  0.3 | 2018-08-23</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>

<p>可以对查询的返回结果进行排序:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT * FROM weather</span></span><br><span class="line">postgres-<span class="comment"># ORDER BY city;</span></span><br><span class="line"> city | temp_lo | temp_hi | prcp |    date    </span><br><span class="line"><span class="comment">------+---------+---------+------+------------</span></span><br><span class="line"> 南京 |      25 |      30 |  0.8 | 2018-08-22</span><br><span class="line"> 南京 |      22 |      30 |  0.3 | 2018-08-23</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>

<p>如果说单一个排序指标无法满足需求,可以添加第二个指标进行更细化的排序</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT * FROM weather</span></span><br><span class="line">postgres-<span class="comment"># ORDER BY city,temp_lo;</span></span><br><span class="line"> city | temp_lo | temp_hi | prcp |    date    </span><br><span class="line"><span class="comment">------+---------+---------+------+------------</span></span><br><span class="line"> 南京 |      22 |      30 |  0.3 | 2018-08-23</span><br><span class="line"> 南京 |      25 |      30 |  0.8 | 2018-08-22</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>

<p>还可以从查询结果中去除重复行:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT DISTINCT city FROM weather;</span></span><br><span class="line"> city</span><br><span class="line"><span class="comment">------</span></span><br><span class="line"> 南京</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><p>除了最常见的单表查询外,我们也可以一次性查询多个表,或者对单表的数据进行不同的处理.这种一次性获取多行的查询叫做<code>join</code>查询</p>
<p>示例:查询南京的天气和位置</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT *</span></span><br><span class="line">postgres-<span class="comment"># FROM weather, cities</span></span><br><span class="line">postgres-<span class="comment"># WHERE city = name;</span></span><br><span class="line"> city | temp_lo | temp_hi | prcp |    date    | name | location </span><br><span class="line"><span class="comment">------+---------+---------+------+------------+------+----------</span></span><br><span class="line"> 南京 |      25 |      30 |  0.8 | 2018-08-22 | 南京 | (32,83)</span><br><span class="line"> 南京 |      22 |      30 |  0.3 | 2018-08-23 | 南京 | (32,83)</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>

<p>由于不同表间没有同名的字段,解析器能够自动将输入的字段对应于正确的列上,但若两个表间有同名的字段,则需要在字段名前加上表名:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> weather.city, weather.temp_lo, weather.temp_hi,</span><br><span class="line">weather.prcp, weather.date, cities.location</span><br><span class="line"><span class="keyword">FROM</span> weather, cities</span><br><span class="line"><span class="keyword">WHERE</span> cities.name = weather.city;</span><br></pre></td></tr></table></figure>

<p>建议无论是否有同名字段都加上表名,这是一个好习惯</p>
<p>上面的查询也可以写成这样:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT *</span></span><br><span class="line">postgres-<span class="comment"># FROM weather INNER JOIN cities ON (weather.city = cities.name);</span></span><br><span class="line"> city | temp_lo | temp_hi | prcp |    date    | name | location </span><br><span class="line"><span class="comment">------+---------+---------+------+------------+------+----------</span></span><br><span class="line"> 南京 |      25 |      30 |  0.8 | 2018-08-22 | 南京 | (32,83)</span><br><span class="line"> 南京 |      22 |      30 |  0.3 | 2018-08-23 | 南京 | (32,83)</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>

<p>这叫做内联合查询(<code>INNER JOIN</code>).这种查询不怎么使用,不过也需要理解其背后的含义:PostgreSQL会扫描<code>weather</code>表中的每一行,然后又会扫描<code>cities</code>表中的每一行去寻找匹配<code>ON</code>子句条件的行.如果匹配成功,则将两张表中匹配的行组合并作为结果输出;如果不匹配则丢弃,并继续寻找</p>
<p>还有一种联合查询叫做外联合查询(<code>OUTER JOIN</code>).它与内联合查询不同之处在于如果匹配不成功,不会丢弃而是以空值的方式显示出来.其按空值显示方式分为左联合(<code>LEFT OUTER JOIN</code>),右联合(<code>RIGHT OUTER JOIN</code>)和全联合(<code>FULL OUTER JOIN</code>)</p>
<p>左联合查询对于不匹配的行,将显示左表的值,而右表将以空值代替:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT *                                                 </span></span><br><span class="line">FROM weather LEFT OUTER JOIN cities ON (weather.city = cities.name);</span><br><span class="line"> city | temp_lo | temp_hi | prcp |    date    | name | location </span><br><span class="line"><span class="comment">------+---------+---------+------+------------+------+----------</span></span><br><span class="line"> 南京 |      25 |      30 |  0.8 | 2018-08-22 | 南京 | (32,83)</span><br><span class="line"> 南京 |      22 |      30 |  0.3 | 2018-08-23 | 南京 | (32,83)</span><br><span class="line"> 上海 |      20 |      33 |  0.2 | 2018-08-21 |      | </span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure>

<p>右联合查询与左联合查询刚好相反,显示右表的值,左表以空值代替:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT *                                                 </span></span><br><span class="line">FROM weather RIGHT OUTER JOIN cities ON (weather.city = cities.name);</span><br><span class="line"> city | temp_lo | temp_hi | prcp |    date    | name | location </span><br><span class="line"><span class="comment">------+---------+---------+------+------------+------+----------</span></span><br><span class="line"> 南京 |      22 |      30 |  0.3 | 2018-08-23 | 南京 | (32,83)</span><br><span class="line"> 南京 |      25 |      30 |  0.8 | 2018-08-22 | 南京 | (32,83)</span><br><span class="line">      |         |         |      |            | 镇江 | (30,90)</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure>

<p>全联合查询则同时显示左右表的值,不匹配的表以空值代替:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT *</span></span><br><span class="line">FROM weather FULL OUTER JOIN cities ON (weather.city = cities.name);</span><br><span class="line"> city | temp_lo | temp_hi | prcp |    date    | name | location </span><br><span class="line"><span class="comment">------+---------+---------+------+------------+------+----------</span></span><br><span class="line"> 南京 |      25 |      30 |  0.8 | 2018-08-22 | 南京 | (32,83)</span><br><span class="line"> 南京 |      22 |      30 |  0.3 | 2018-08-23 | 南京 | (32,83)</span><br><span class="line"> 上海 |      20 |      33 |  0.2 | 2018-08-21 |      | </span><br><span class="line">      |         |         |      |            | 镇江 | (30,90)</span><br><span class="line">(4 rows)</span><br></pre></td></tr></table></figure>

<p>还有一种查询叫做自联合查询(<code>SELF JOIN</code>).它与普通的联合查询并无实质性区别,只不过把同一个表当作两个表罢了</p>
<p>例如:查询温度范围在其它温度范围之间的城市</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT W1.city, W1.temp_lo AS low, W1.temp_hi AS high,</span></span><br><span class="line">postgres-<span class="comment"># W2.city, W2.temp_lo AS low, W2.temp_hi AS high</span></span><br><span class="line">postgres-<span class="comment"># FROM weather W1, weather W2</span></span><br><span class="line">postgres-<span class="comment"># WHERE W1.temp_lo &lt; W2.temp_lo</span></span><br><span class="line">postgres-<span class="comment"># AND W1.temp_hi &gt; W2.temp_hi;</span></span><br><span class="line"> city | low | high | city | low | high </span><br><span class="line"><span class="comment">------+-----+------+------+-----+------</span></span><br><span class="line"> 上海 |  20 |   33 | 南京 |  25 |   30</span><br><span class="line"> 上海 |  20 |   33 | 南京 |  22 |   30</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>

<p>为了区分同一张表,需要将它们设为不同的标签:<code>weather W1</code>,<code>weather W2</code></p>
<h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><p>和其它的关系型数据库一样,<code>PostgreSQL</code>也支持聚合函数(<code>aggregate functions</code>).聚合函数指能从多行输入计算单一的结果的函数.例如,我们可以对一些行计算它们的<code>count</code>,<code>sum</code>,<code>avg</code>,<code>max</code>,<code>min</code>等等</p>
<p>例如:找出最高的每日最低温度</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT max(temp_lo) FROM weather;</span></span><br><span class="line"> max </span><br><span class="line"><span class="comment">-----</span></span><br><span class="line">  25</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>这样的话我们就可以求出最低温度的那行记录:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT * FROM weather WHERE temp_lo=(SELECT max(temp_lo) FROM weather);</span></span><br><span class="line"> city | temp_lo | temp_hi | prcp |    date    </span><br><span class="line"><span class="comment">------+---------+---------+------+------------</span></span><br><span class="line"> 南京 |      25 |      30 |  0.8 | 2018-08-22</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>聚合函数经常与<code>GROUP BY</code>子句组合使用.例如:找出每个城市的最高每日最低温度</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT city, max(temp_lo)</span></span><br><span class="line">postgres-<span class="comment"># FROM weather</span></span><br><span class="line">postgres-<span class="comment"># GROUP BY city;</span></span><br><span class="line"> city | max </span><br><span class="line"><span class="comment">------+-----</span></span><br><span class="line"> 南京 |  25</span><br><span class="line"> 上海 |  20</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>

<p>还有,如果我们想对聚合查询的结果做个过滤的话,则可以使用<code>HAVING</code>子句:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT city, max(temp_lo)</span></span><br><span class="line">postgres-<span class="comment"># FROM weather</span></span><br><span class="line">postgres-<span class="comment"># GROUP BY city</span></span><br><span class="line">postgres-<span class="comment"># HAVING max(temp_lo) &lt;= 20;</span></span><br><span class="line"> city | max </span><br><span class="line"><span class="comment">------+-----</span></span><br><span class="line"> 上海 |  20</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>最后,如果我们只关心”上”开头的城市,我们可以使用<code>LIKE</code>关键字:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># SELECT city, max(temp_lo)</span></span><br><span class="line">FROM weather</span><br><span class="line">WHERE city LIKE '上%' GROUP BY city;</span><br><span class="line"> city | max </span><br><span class="line"><span class="comment">------+-----</span></span><br><span class="line"> 上海 |  20</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>注意<code>WHERE</code>和<code>HAVING</code>的区别:</p>
<ol>
<li><code>WHERE</code>子句一定不能包含聚合函数.因为无法使用聚合函数决定传递给聚合函数的行数据</li>
<li><code>HAVING</code>子句往往和聚合函数一起使用.虽然严格来说不与聚合函数一起使用也可以,但那样的话一定是使用<code>WHERE</code>更加有效</li>
</ol>
<p>查询过程如下:</p>
<ol>
<li><code>WHERE</code>子句对表中的每一行进行筛选与过滤</li>
<li>筛选后的行将会送给<code>GROUP BY</code>子句进行分组</li>
<li>分组后的行将分别由聚合函数求出结果</li>
<li>聚合函数的结果将传递给<code>HAVING</code>子句,进行进一步的过滤</li>
<li>返回最终的结果</li>
</ol>
<h2 id="更新-update"><a href="#更新-update" class="headerlink" title="更新(update)"></a>更新(update)</h2><p><code>UPDATE</code>命令用于更新存在的行.例如如果想要将温度换成华氏度:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> weather</span><br><span class="line"><span class="keyword">SET</span> temp_hi = temp_hi * <span class="number">1.8</span> + <span class="number">32</span>, temp_lo = temp_lo * <span class="number">1.8</span> + <span class="number">32</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="built_in">date</span> &gt; <span class="string">'1994-11-28'</span>;</span><br></pre></td></tr></table></figure>

<h2 id="删除-delete"><a href="#删除-delete" class="headerlink" title="删除(delete)"></a>删除(delete)</h2><p><code>DELETE</code>命令用于移除表中的某些行.例如删除城市为南京的记录:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> weather <span class="keyword">WHERE</span> city = <span class="string">'上海'</span>;</span><br></pre></td></tr></table></figure>

<p>这样所有关于南京的行都将被删除</p>
<p>注意谨慎使用没有筛选的<code>DELETE</code>命令:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> tablename;</span><br></pre></td></tr></table></figure>

<p>没有筛选的话,<code>DELETE</code>将会删除给定表的所有行,并且没有提示确认信息</p>
<h2 id="视图-view"><a href="#视图-view" class="headerlink" title="视图(view)"></a>视图(view)</h2><p>试想一下,我们经常需要将天气记录和城市位置组合起来查询,但是每次都需要联合查询实在是太累了,这时我们就可以创建一个视图(view):</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># CREATE VIEW myview AS</span></span><br><span class="line">postgres-<span class="comment"># SELECT city, temp_lo, temp_hi, prcp, date, location</span></span><br><span class="line">postgres-<span class="comment"># FROM weather, cities</span></span><br><span class="line">postgres-<span class="comment"># WHERE city = name;</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span></span><br></pre></td></tr></table></figure>

<p>查询视图:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># select * from myview;</span></span><br><span class="line"> city | temp_lo | temp_hi | prcp |    date    | location </span><br><span class="line"><span class="comment">------+---------+---------+------+------------+----------</span></span><br><span class="line"> 南京 |      23 |      28 |  0.8 | 2018-08-22 | (32,83)</span><br><span class="line"> 南京 |      20 |      28 |  0.3 | 2018-08-23 | (32,83)</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>

<p>视图的使用与表几乎一样.视图没有真正的存储数据,它所有的数据都是表的行的引用.可以看出,视图与表属于同级结构:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># \d</span></span><br><span class="line">          List of relations</span><br><span class="line"> Schema |  Name   | Type  |  Owner   </span><br><span class="line"><span class="comment">--------+---------+-------+----------</span></span><br><span class="line"> public | cities  | table | postgres</span><br><span class="line"> public | myview  | view  | postgres</span><br><span class="line"> public | weather | table | postgres</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure>

<p>一个好的数据库设计经常需要用到视图,它在表与查询接口间添加了一个中间层,当表改变时,往往改变视图而无需更改接口.任何使用表的方法几乎都能在视图上使用,甚至在视图上创建视图</p>
<h2 id="外键-foreign-key"><a href="#外键-foreign-key" class="headerlink" title="外键(foreign key)"></a>外键(foreign key)</h2><p>外键用于解决这样如这样的情况:我们需要确保当<code>cities</code>表没有匹配的城市的话,没人能够在<code>weather</code>表插入相关城市的行.这叫做维护参照完整性(<code>referential integrity</code>)</p>
<p>示例:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># CREATE TABLE cities (</span></span><br><span class="line">postgres(<span class="comment"># city varchar(80) primary key,</span></span><br><span class="line">postgres(<span class="comment"># location point</span></span><br><span class="line">postgres(<span class="comment"># );</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span></span><br><span class="line"></span><br><span class="line">postgres=<span class="comment"># CREATE TABLE weather (</span></span><br><span class="line">postgres(<span class="comment"># city varchar(80) references cities(city),</span></span><br><span class="line">postgres(<span class="comment"># temp_lo int,</span></span><br><span class="line">postgres(<span class="comment"># temp_hi int,</span></span><br><span class="line">postgres(<span class="comment"># prcp real,</span></span><br><span class="line">postgres(<span class="comment"># date date</span></span><br><span class="line">postgres(<span class="comment"># );</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span></span><br></pre></td></tr></table></figure>

<p>现在,插入<code>weather</code>表中的行必须是<code>cities</code>表中有的城市.现在尝试插入一个非法的记录:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># INSERT INTO weather VALUES ('杭州',20,30,0.0,'2018-8-25');</span></span><br><span class="line">ERROR:  <span class="keyword">insert</span> <span class="keyword">or</span> <span class="keyword">update</span> <span class="keyword">on</span> <span class="keyword">table</span> <span class="string">"weather"</span> violates <span class="keyword">foreign</span> <span class="keyword">key</span> <span class="keyword">constraint</span> <span class="string">"weather_city_fkey"</span></span><br><span class="line">DETAIL:  <span class="keyword">Key</span> (city)=(杭州) <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">present</span> <span class="keyword">in</span> <span class="keyword">table</span> <span class="string">"cities"</span>.</span><br></pre></td></tr></table></figure>

<p>可以看到明显的报错</p>
<h2 id="事务-transaction"><a href="#事务-transaction" class="headerlink" title="事务(transaction)"></a>事务(transaction)</h2><p>事务是所有数据库系统的基础功能.事务的本质是将多个步骤合为单个的,全或无的操作.步骤之间的中间态是不会被其它并行事务看到的.并且一旦有操作执行失败,那么该事务将不会对数据库有任何影响</p>
<p>事务具有四个特征:原子性(<code>Atomicity</code>),一致性(<code>Consistency</code>),隔离性(<code>Isolation</code>),持续性(<code>Durability</code>)</p>
<ul>
<li>原子性:事务由多个语句组成,原子性保证每一次事务都被当作一个单独的单元,即要么完全失败,要么完全成功.如果任意一个事务中的语句执行失败,那么整次事务都将失败,且数据库不会发生任何改变.一个原子的系统需要保证任何情况下的原子性,包括断电,报错等等</li>
<li>一致性:一致性确保一次事务只能使数据库从一个有效的状态到另一个有效的状态.任何写入的数据必须符合定义的规则,包括约束,级联,触发器等等.这将防止数据库被非法的事务所损坏</li>
<li>隔离性:事务经常是并发执行(同一时间读,写多个表),隔离性保证其它并发执行的事务不会看到正在执行的事务的任何修改,并且如果发生冲突(比如同时写一个表),那么这些事务就要顺序执行.隔离性的主要目的是并发控制</li>
<li>持续性:持续性保证一旦事务提交,那么数据库将一直是提交后的状态,即使发生了系统错误.这经常指完成后的事务将保存在永久性存储中</li>
</ul>
<p>在<code>PostgreSQL</code>中,一次事务指使用<code>BEGIN</code>和<code>COMMIT</code>命令包起来的<code>SQL</code>命令.例如:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">postgres=<span class="comment"># BEGIN;</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">postgres=<span class="comment"># UPDATE weather SET temp_lo = temp_lo - 5 WHERE city = '南京';</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="number">1</span></span><br><span class="line">postgres=<span class="comment"># COMMIT;</span></span><br><span class="line"><span class="keyword">COMMIT</span></span><br></pre></td></tr></table></figure>

<p>如果在事务中途,我们决定不想提交了,可以使用<code>ROLLBACK</code>命令代替<code>COMMIT</code>命令,这样所有<code>BEGIN</code>语句后的操作都将被取消</p>
<p>事实上,在<code>PostgreSQL</code>中每一个<code>SQL</code>语句都是在一次事务中执行的.如果不使用<code>BEGIN</code>命令指定,每一个单独的命令都会有一对<code>BEGIN</code>和<code>COMMIT</code>命令包装它.有时,多个被<code>BEGIN</code>和<code>COMMIT</code>命令包装的语句被称为事务块(<code>transaction block</code>)</p>
<p>可以使用<code>SAVEPOINT</code>控制事务块的流程.默认情况下<code>ROLLBACK</code>将事务退回至<code>BEGIN</code>处,而当指定<code>SAVEPOINT</code>后,<code>ROLLBACK</code>也可以选择退回至<code>SAVEPOINT</code>处:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance = balance - <span class="number">100.00</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'Alice'</span>;</span><br><span class="line"><span class="keyword">SAVEPOINT</span> my_savepoint;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance = balance + <span class="number">100.00</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'Bob'</span>;</span><br><span class="line"><span class="comment">-- oops ... forget that and use Wally's account</span></span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> my_savepoint;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance = balance + <span class="number">100.00</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'Wally'</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p><code>ROLLBACK TO</code>是当事务块发生错误时还能重新获得控制的唯一的方法.因此当需要操作复杂事务时应合理使用<code>SAVEPOINT</code></p>
<h2 id="窗口函数-window-function"><a href="#窗口函数-window-function" class="headerlink" title="窗口函数(window function)"></a>窗口函数(window function)</h2><p>窗口函数从一系列行执行一种计算,这和聚集函数十分类似.与之不同的是,聚集函数多行返回单一结果,而窗口函数则每一行都有一个结果</p>
<p>例如:展示一个员工的薪水和其所在部门的平均薪水</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> depname, empno, salary, <span class="keyword">avg</span>(salary) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> depname) <span class="keyword">FROM</span> empsalary;</span><br></pre></td></tr></table></figure>

<p>输出结果:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  depname  | empno | salary |          avg</span><br><span class="line"><span class="comment">-----------+-------+--------+-----------------------</span></span><br><span class="line"> develop   |    11 |   5200 | 5020.0000000000000000</span><br><span class="line"> develop   |     7 |   4200 | 5020.0000000000000000</span><br><span class="line"> develop   |     9 |   4500 | 5020.0000000000000000</span><br><span class="line"> develop   |     8 |   6000 | 5020.0000000000000000</span><br><span class="line"> develop   |    10 |   5200 | 5020.0000000000000000</span><br><span class="line"> personnel |     5 |   3500 | 3700.0000000000000000</span><br><span class="line"> personnel |     2 |   3900 | 3700.0000000000000000</span><br><span class="line"> sales     |     3 |   4800 | 4866.6666666666666667</span><br><span class="line"> sales     |     1 |   5000 | 4866.6666666666666667</span><br><span class="line"> sales     |     4 |   4800 | 4866.6666666666666667</span><br><span class="line">(10 rows)</span><br></pre></td></tr></table></figure>

<p>最开始的三个输出列直接来自于表<code>empsalary</code>,第四列表示对与当前行具有相同<code>depname</code>值的所有表行取得平均值,<code>avg()</code>实际上是聚合函数,只是<code>OVER</code>子句使它当作一个窗口函数处理并通过窗口帧计算</p>
<p>一个窗口函数调用总是包含一个窗口函数名称和紧跟着的<code>OVER</code>子句.这就是窗口函数区别于普通函数和聚合函数的地方.<code>OVER</code>子句决定了有哪些行分离出来并交给窗口函数处理.<code>PARTITION BY</code>子句将具有相同值的行分到相同的组中.对于每一行,窗口函数都会在同一分区的行上做运算</p>
<p>可以使用<code>ORDER BY</code>子句控制窗口函数处理行的顺序:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> depname, empno, salary, <span class="keyword">rank</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> depname <span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>) <span class="keyword">FROM</span> empsalary;</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  depname  | empno | salary | rank</span><br><span class="line"><span class="comment">-----------+-------+--------+------</span></span><br><span class="line"> develop   |     8 |   6000 |    1</span><br><span class="line"> develop   |    10 |   5200 |    2</span><br><span class="line"> develop   |    11 |   5200 |    2</span><br><span class="line"> develop   |     9 |   4500 |    4</span><br><span class="line"> develop   |     7 |   4200 |    5</span><br><span class="line"> personnel |     2 |   3900 |    1</span><br><span class="line"> personnel |     5 |   3500 |    2</span><br><span class="line"> sales     |     1 |   5000 |    1</span><br><span class="line"> sales     |     4 |   4800 |    2</span><br><span class="line"> sales     |     3 |   4800 |    2</span><br><span class="line">(10 rows)</span><br></pre></td></tr></table></figure>

<p>如上,<code>rank()</code>函数按<code>ORDER BY</code>子句的顺序为每一个按<code>PARTITION BY</code>分的组的每一行产生一个数字等级</p>
<p>窗口函数作用于已经过<code>WHERE</code>,<code>GROUP BY</code>,<code>HAVING</code>过滤的虚拟表.随后,窗口函数使用<code>OVER</code>子句划分数据</p>
<p>如果行的顺序不重要,<code>ORDER BY</code>语句可以忽略;如果不需要将行划分为多个部分,则不需要使用<code>PARTITION BY</code>语句</p>
<p>窗口函数还有另外一个重要的概念叫做窗口帧(<code>window frame</code>),一些窗口函数只对窗口函数有效,而非整个部分.默认情况下,如果使用了<code>ORDER BY</code>语句,那么窗口帧包括从划分部分的第一行一直到当前行的所有行,以及接下来依据<code>ORDER BY</code>的相等的行;如果没有使用<code>ORDER BY</code>,那么窗口帧包括整个部分</p>
<p>以工资总额查询示例:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> salary, <span class="keyword">sum</span>(salary) <span class="keyword">OVER</span> () <span class="keyword">FROM</span> empsalary;</span><br></pre></td></tr></table></figure>

<p>结果:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> salary |  sum  </span><br><span class="line"><span class="comment">--------+-------</span></span><br><span class="line">   5200 | 47100</span><br><span class="line">   5000 | 47100</span><br><span class="line">   3500 | 47100</span><br><span class="line">   4800 | 47100</span><br><span class="line">   3900 | 47100</span><br><span class="line">   4200 | 47100</span><br><span class="line">   4500 | 47100</span><br><span class="line">   4800 | 47100</span><br><span class="line">   6000 | 47100</span><br><span class="line">   5200 | 47100</span><br><span class="line">(10 rows)</span><br></pre></td></tr></table></figure>

<p>如上,由于缺少<code>PARTITION BY</code>,窗口函数不会将表划分为多个部分;由于缺少<code>ORDER BY</code>,窗口帧就是整个部分.也就是说,每个合计都在整个表上执行,这样的话每个输出结果都相同</p>
<p>再试试加上<code>ORDER BY</code>语句:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> salary, <span class="keyword">sum</span>(salary) <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> salary) <span class="keyword">FROM</span> empsalary;</span><br></pre></td></tr></table></figure>

<p>结果:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">salary |  sum</span><br><span class="line"><span class="comment">--------+-------</span></span><br><span class="line">   3500 |  3500</span><br><span class="line">   3900 |  7400</span><br><span class="line">   4200 | 11600</span><br><span class="line">   4500 | 16100</span><br><span class="line">   4800 | 25700</span><br><span class="line">   4800 | 25700</span><br><span class="line">   5000 | 30700</span><br><span class="line">   5200 | 41100</span><br><span class="line">   5200 | 41100</span><br><span class="line">   6000 | 47100</span><br><span class="line">(10 rows)</span><br></pre></td></tr></table></figure>

<p>这里salary由从小到大的顺序排,而sum串口构函数的计算则是从第一行到当前行,以及之后的与当前行相同的行(注意salary为4800的行)</p>
<p>窗口函数只允许出现在查询的<code>SELECT</code>列表和<code>ORDER BY</code>子句中,因为窗口函数的执行是在处理完过滤,分类等等之后.另外,窗口函数在聚集函数之后执行,这意味着窗口函数的参数可以包括一个聚集函数,反之不行</p>
<p>如果需要在窗口函数执行完进行过滤或分组,可以使用子查询:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> depname, empno, salary, enroll_date</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  (<span class="keyword">SELECT</span> depname, empno, salary, enroll_date,</span><br><span class="line">          <span class="keyword">rank</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> depname <span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>, empno) <span class="keyword">AS</span> pos</span><br><span class="line">     <span class="keyword">FROM</span> empsalary</span><br><span class="line">  ) <span class="keyword">AS</span> ss</span><br><span class="line"><span class="keyword">WHERE</span> pos &lt; <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>当一个查询涉及到多个窗口函数时,可以将每一个分别写到独立的<code>OVER</code>子句中;但如果多个窗口函数要求的窗口函数行为一样时,为了简便,可以将窗口函数单独定义,然后在每个需要使用的窗口函数中引用它:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">sum</span>(salary) <span class="keyword">OVER</span> w, <span class="keyword">avg</span>(salary) <span class="keyword">OVER</span> w</span><br><span class="line">  <span class="keyword">FROM</span> empsalary</span><br><span class="line">  <span class="keyword">WINDOW</span> w <span class="keyword">AS</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> depname <span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>);</span><br></pre></td></tr></table></figure>

<h2 id="继承-Inheritance"><a href="#继承-Inheritance" class="headerlink" title="继承(Inheritance)"></a>继承(Inheritance)</h2><p>类似面向对象语言中的继承,使用了继承的表将会拥有其父表的所有字段:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> cities (</span><br><span class="line">  <span class="keyword">name</span>       <span class="built_in">text</span>,</span><br><span class="line">  population <span class="built_in">real</span>,</span><br><span class="line">  altitude   <span class="built_in">int</span>     <span class="comment">-- (in ft)</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> capitals (</span><br><span class="line">  state      <span class="built_in">char</span>(<span class="number">2</span>)</span><br><span class="line">) INHERITS (cities);</span><br></pre></td></tr></table></figure>

<p>并且,当查询父表时,子表的数据也将纳入查询范围中:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>, altitude</span><br><span class="line">  <span class="keyword">FROM</span> cities</span><br><span class="line">  <span class="keyword">WHERE</span> altitude &gt; <span class="number">500</span>;</span><br></pre></td></tr></table></figure>

<p>如果只需要查询父表而不涉及到继承层次中位于父表之下的其他表,则需要添加<code>ONLY</code>关键字:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>, altitude</span><br><span class="line">    <span class="keyword">FROM</span> <span class="keyword">ONLY</span> cities</span><br><span class="line">    <span class="keyword">WHERE</span> altitude &gt; <span class="number">500</span>;</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/PostgreSQL/" rel="tag"><i class="fa fa-tag"></i> PostgreSQL</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2018/08/25/PostgreSQL%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3/" rel="prev" title="PostgreSQL初步了解">
      <i class="fa fa-chevron-left"></i> PostgreSQL初步了解
    </a></div>
      <div class="post-nav-item">
    <a href="/2018/09/01/arp%E6%AC%BA%E9%AA%97/" rel="next" title="arp欺骗">
      arp欺骗 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL语言简介"><span class="nav-number">1.</span> <span class="nav-text">SQL语言简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建表格-create"><span class="nav-number">2.</span> <span class="nav-text">创建表格(create)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#删除表格-drop"><span class="nav-number">3.</span> <span class="nav-text">删除表格(drop)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#插入-insert"><span class="nav-number">4.</span> <span class="nav-text">插入(insert)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#查询-select"><span class="nav-number">5.</span> <span class="nav-text">查询(select)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多表查询"><span class="nav-number">6.</span> <span class="nav-text">多表查询</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#聚合函数"><span class="nav-number">7.</span> <span class="nav-text">聚合函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#更新-update"><span class="nav-number">8.</span> <span class="nav-text">更新(update)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#删除-delete"><span class="nav-number">9.</span> <span class="nav-text">删除(delete)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#视图-view"><span class="nav-number">10.</span> <span class="nav-text">视图(view)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#外键-foreign-key"><span class="nav-number">11.</span> <span class="nav-text">外键(foreign key)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事务-transaction"><span class="nav-number">12.</span> <span class="nav-text">事务(transaction)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#窗口函数-window-function"><span class="nav-number">13.</span> <span class="nav-text">窗口函数(window function)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承-Inheritance"><span class="nav-number">14.</span> <span class="nav-text">继承(Inheritance)</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="staight"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">staight</p>
  <div class="site-description" itemprop="description">keep it simple and stupid</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">68</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">staight</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,255,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  <script type="text/javascript" async src="/js/ribbon.js"></script>
</body>
</html>
